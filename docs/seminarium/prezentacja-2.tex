\documentclass[aspectratio=169]{beamer}

% Podstawowe pakiety
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[polish]{babel}
\usepackage{helvet}
\usepackage{amssymb} % Dla symbolu mathbb{E}
\usepackage{amsmath}

% Konfiguracja Beamer
\usetheme{Madrid}
\usecolortheme{dove}
\setbeamertemplate{navigation symbols}{}
\setbeamerfont{frametitle}{size=\large}
\date{}

% Pakiety graficzne
\usepackage{tikz}
\usepackage{pgfplots}
\usetikzlibrary{3d, shapes, arrows.meta, positioning, fit, backgrounds, calc, shadows, shapes.geometric, decorations.pathreplacing, chains, matrix}
\usepackage{fontawesome5}
\usepackage{booktabs}

% Kolory
\definecolor{bertBlue}{RGB}{235, 245, 251}
\definecolor{bertBorder}{RGB}{52, 152, 219}
\definecolor{clsGold}{RGB}{241, 196, 15}
\definecolor{clsBorder}{RGB}{183, 149, 11}
\definecolor{tokenGray}{RGB}{236, 240, 241}
\definecolor{headRed}{RGB}{231, 76, 60}
\definecolor{goodGreen}{RGB}{46, 204, 113}
\definecolor{opPurple}{RGB}{155, 89, 182}
\definecolor{stageOrange}{RGB}{158, 108, 49}
\definecolor{bertcolor}{RGB}{70, 130, 180}
\definecolor{imdbcolor}{RGB}{231, 76, 60}
\definecolor{hypercolor}{RGB}{46, 204, 113}
\definecolor{arxivcolor}{RGB}{241, 196, 15}
\definecolor{gridcolor}{RGB}{155, 89, 182}
\definecolor{freezecolor}{RGB}{52, 152, 219}
\definecolor{dropcolor}{RGB}{230, 126, 34}
\definecolor{poolcolor}{RGB}{26, 188, 156}
\definecolor{evalcolor}{RGB}{150, 150, 150}
\definecolor{bglight}{RGB}{248, 249, 250}

\definecolor{lshcolor}{RGB}{52, 152, 219}
\definecolor{favorcolor}{RGB}{46, 204, 113}
\definecolor{pretraincolor}{RGB}{155, 89, 182}
\definecolor{taptcolor}{RGB}{230, 126, 34}
\definecolor{finetunecolor}{RGB}{231, 76, 60}
\definecolor{bglight}{RGB}{248, 249, 250}
\definecolor{bggray}{RGB}{236, 240, 241}

\definecolor{myblue}{RGB}{220, 230, 240}
\definecolor{myyellow}{RGB}{255, 250, 205}
\definecolor{myred}{RGB}{250, 200, 200}
\definecolor{mygreen}{RGB}{200, 230, 200}
\definecolor{mygrid}{RGB}{180, 180, 180}

\newsavebox{\tempSlideBox}

\begin{document}

%slajd 1
\begin{frame}{Pełny Proces Treningu}
    \centering
    \resizebox{!}{0.85\textheight}{
    \begin{tikzpicture}[
        % --- STYLE ZGODNE Z POPRZEDNIMI SLAJDAMI ---
        % Styl ogólny (jak 'process' w poprzednich)
        generalBox/.style={draw=gray, thick, rounded corners, fill=white, align=center, font=\footnotesize},
    %
        % DANE (kolumna lewa)
        data/.style={
            generalBox,
            text width=3.8cm,
            minimum height=1.6cm,
        },
        % PROCES (kolumna środkowa)
        process/.style={
            generalBox,
            text width=4.8cm,
            minimum height=1.8cm,
        },
        % MODEL (BERT) - Styl 'bert' (niebieski)
        bert/.style={
            draw=bertBorder, 
            fill=bertBlue!30, 
            line width=1.5pt, 
            rounded corners,
            align=center,
            font=\bfseries\small,
            minimum width=2cm,
            minimum height=1cm
        },
        % GŁOWY (MLM/CLS) - Styl 'head' (czerwony)
        head/.style={
            draw=headRed, 
            fill=headRed!10, 
            thick, 
            rounded corners,
            align=center,
            font=\scriptsize\bfseries,
            minimum width=1.8cm,
            minimum height=0.8cm
        },
        % STRZAŁKI
        arrow/.style={->, >=Stealth, thick, color=gray!70},
        dashed_arrow/.style={arrow, dashed},
    %
        % RAMKA ETAPU
        stage_frame/.style={
            draw=stageOrange,
            line width=1pt,
            rounded corners=8pt,
            inner sep=10pt,
            fill=stageOrange!10
        },
        % TYTUŁ ETAPU
        stage_label/.style={
            font=\bfseries\small,
            text=stageOrange,
            anchor=east
        }
    ]
    %
    % ================= KOORDYNATY =================
    \def\yOne{3.2}
    \def\yTwo{0}
    \def\yThree{-3.2}
    %
    \def\xData{-5}
    \def\xProc{0.5}
    \def\xModel{5.5}
    %
    % ================= NAGŁÓWKI KOLUMN =================
    % Pusty węzeł dla obniżenia całości (górny margines)
    \path (0, 5.8) node {};

    \node[font=\bfseries\footnotesize, text=gray] at (\xData, 5.0) {DANE};
    \node[font=\bfseries\footnotesize, text=gray] at (\xProc, 5.0) {PROCES UCZENIA};
    \node[font=\bfseries\footnotesize, text=gray] at (\xModel+1, 5.0) {MODEL};
    %
    % ================= ETAP 1 =================
    % Elementy
    \node[data] (d1) at (\xData, \yOne) {
        \textbf{Wikipedia}\\[3pt]
        \scriptsize 450k $\times$ 512 \\
        150k $\times$ 128
    };
    \node[process] (p1) at (\xProc, \yOne) {
        \textbf{Pre-training (MLM)}\\[3pt]
        \footnotesize Maskowanie tokenów\\
        \textit{\color{gray}Ogólna reprezentacja języka}
    };
    \node[bert] (b1) at (\xModel, \yOne) {BERT};
    \node[head, right=0.2cm of b1] (h1) {Głowa\\MLM};

    % Połączenia
    \draw[arrow] (d1) -- (p1);
    \draw[arrow] (p1) -- (b1);
    \draw[dashed_arrow] (b1) -- (h1);

    % Ramka i podpis etapu 1
    \begin{scope}[on background layer]
        \node[stage_frame, fit=(d1)(h1)] (frame1) {};
        \node[stage_label] at ($(frame1.west)+(-0.2, 0)$) {ETAP 1};
    \end{scope}
    %
    %
    % ================= ETAP 2 =================
    % Elementy
    \node[data] (d2) at (\xData, \yTwo) {
        \textbf{Korpus docelowy}\\[3pt]
        \scriptsize IMDB: 40k $\times$ 512\\
        Hyperpartisan: 50k $\times$ 4096\\
        ArXiv: 26.7k $\times$ 16384
    };
    \node[process] (p2) at (\xProc, \yTwo) {
        \textbf{TAPT (MLM)}\\[3pt]
        \footnotesize Adaptacja domenowa\\
        \textit{\color{gray}Specjalizacja do zadania}
    };
    \node[bert] (b2) at (\xModel, \yTwo) {BERT};
    \node[head, right=0.2cm of b2] (h2) {Głowa\\MLM};

    % Połączenia
    \draw[arrow] (d2) -- (p2);
    \draw[arrow] (p2) -- (b2);
    \draw[dashed_arrow] (b2) -- (h2);

    % Ramka i podpis etapu 2
    \begin{scope}[on background layer]
        \node[stage_frame, fit=(d2)(h2)] (frame2) {};
        \node[stage_label] at ($(frame2.west)+(-0.2, 0)$) {ETAP 2};
    \end{scope}
    %
    %
    % ================= ETAP 3 =================
    % Elementy
    \node[data] (d3) at (\xData, \yThree) {
        \textbf{Dane z etykietami}\\[3pt]
        \scriptsize IMDB: 2 klasy\\
        Hyperpartisan: 2 klasy\\
        ArXiv: 11 klas
    };
    \node[process] (p3) at (\xProc, \yThree) {
        \textbf{Fine-tuning}\\[3pt]
        \footnotesize Uczenie nadzorowane\\
        \textit{\color{gray}Predykcja klas}
    };
    \node[bert] (b3) at (\xModel, \yThree) {BERT};
    % Głowa CLS
    \node[head, right=0.2cm of b3] (h3) {Głowa\\CLS};

    % Połączenia
    \draw[arrow] (d3) -- (p3);
    \draw[arrow] (p3) -- (b3);
    \draw[dashed_arrow] (b3) -- (h3);

    % Ramka i podpis etapu 3
    \begin{scope}[on background layer]
        \node[stage_frame, fit=(d3)(h3)] (frame3) {};
        \node[stage_label] at ($(frame3.west)+(-0.2, 0)$) {ETAP 3};
    \end{scope}
    %
    %
    % ================= TRANSFER WAG (PIONOWE) =================
    \draw[arrow] (b1) -- (b2) node[midway, right, font=\scriptsize, text=gray] {transfer wag};
    \draw[arrow] (b2) -- (b3) node[midway, right, font=\scriptsize, text=gray] {transfer wag};
    %
    %
    % ================= RAMKA BACKBONE =================
    \begin{scope}[on background layer]
        \node[
            draw=bertBorder, dashed, line width=1.5pt,
            rounded corners=8pt,
            fit=(b1)(b3)(h1)(h3),
            inner sep=6pt, yshift=-2pt
        ] (backbone) {};
        
        % Etykieta ramki
        \node[anchor=north, text=bertBorder, font=\scriptsize\bfseries, yshift=-8pt] at (backbone.south) {BACKBONE WSPÓŁDZIELONY};
    \end{scope}
    %
    %
    % (Usunięto strzałkę specjalizacji)

    \end{tikzpicture}
    }
\end{frame}

%slajd 2
\begin{frame}[fragile]
\frametitle{Optymalizacja hiperparametrów Finetuningu}
\resizebox{!}{0.9\textheight}{%

\begin{tikzpicture}[
    node distance=0.6cm and 0.8cm,
    >={Stealth[round]},
    box/.style={rectangle, rounded corners=3pt, draw=#1, fill=#1!15, 
                minimum width=2.2cm, minimum height=0.7cm, 
                font=\footnotesize\bfseries, text=black, line width=0.8pt},
    smallbox/.style={rectangle, rounded corners=2pt, draw=#1, fill=#1!20,
                     minimum width=1.6cm, minimum height=0.5cm,
                     font=\scriptsize\bfseries, text=black},
    gridbox/.style={rectangle, rounded corners=4pt, draw=gridcolor, fill=gridcolor!10,
                    minimum width=5.5cm, minimum height=2.8cm, line width=1pt},
    arrow/.style={->, line width=1pt, color=#1},
    dasharrow/.style={->, dashed, line width=0.8pt, color=gray}
]

% Invisible node to shift the diagram to the right
\path (-5,0) node {};
\path (0,0.5) node {};


% Zbiory danych
\node[smallbox=hypercolor] (hyper) {Hyperpartisan};
\node[smallbox=imdbcolor, left=0.5cm of hyper] (imdb) {IMDB};
\node[smallbox=arxivcolor, right=0.5cm of hyper] (arxiv) {ArXiv};

% Grid Search box
\node[gridbox, below=1.0cm of hyper] (grid) {};
\node[above=0.05cm of grid.north, font=\footnotesize\bfseries, text=gridcolor] (gridtitle)
    {\faIcon{th} \, GRID SEARCH};

% 12 konfiguracji pod napisem Grid Search
\node[below=0.05cm of gridtitle, font=\tiny, text=gray] (config) {12 konfiguracji};

% Zawartość Grid Search - 3 czynniki
\node[below=0.15cm of config, font=\scriptsize] (g1) {
    \textcolor{freezecolor}{\faIcon{snowflake}} \, $N_{\text{freeze}} \in \{0, 1, 2\}$
};
\node[below=0.1cm of g1, font=\scriptsize] (g2) {
    \textcolor{dropcolor}{\faIcon{tint}} \, $P_{\text{drop}} \in \{0.1, 0.2\}$
};
\node[below=0.1cm of g2, font=\scriptsize] (g3) {
    \textcolor{poolcolor}{\faIcon{layer-group}} \, Pooling: CLS / Mean
};


% Strzałki od zbiorów do napisu Grid Search
\draw[arrow=imdbcolor!70] (imdb.south) -- (gridtitle.west);
\draw[arrow=hypercolor!70] (hyper.south) -- (gridtitle.north);
\draw[arrow=arxivcolor!70] (arxiv.south) -- (gridtitle.east);

% Ewaluacja
\node[box=evalcolor, below=0.8cm of grid, minimum width=3.8cm] (eval) 
    {\faIcon{chart-bar} \, Ewaluacja: $F_1$-macro};

\draw[arrow=gridcolor] (grid.south) -- (eval.north);

% Wyniki - optymalne HP
\node[smallbox=imdbcolor, below left=0.7cm and 0.3cm of eval] (hp1) {HP\textsubscript{IMDB}};
\node[smallbox=hypercolor, below=0.7cm of eval] (hp2) {HP\textsubscript{Hyper}};
\node[smallbox=arxivcolor, below right=0.7cm and 0.3cm of eval] (hp3) {HP\textsubscript{ArXiv}};

\draw[arrow=evalcolor] (eval.south) -- ++(0,-0.25) -| (hp1.north);
\draw[arrow=evalcolor] (eval.south) -- (hp2.north);
\draw[arrow=evalcolor] (eval.south) -- ++(0,-0.25) -| (hp3.north);

% Następne eksperymenty
\node[box=gray, below=0.7cm of hp2, minimum width=3cm] (next) 
    {\faIcon{arrow-right} \, Exp. LSH/FAVOR};

\draw[dasharrow] (hp1.south) |- ([yshift=0.2cm]next.west);
\draw[dasharrow] (hp2.south) -- (next.north);
\draw[dasharrow] (hp3.south) |- ([yshift=0.2cm]next.east);

% Podsumowanie na dole
\node[rectangle, rounded corners=5pt, draw=evalcolor, fill=evalcolor!10,
      minimum width=10cm, minimum height=0.6cm, font=\scriptsize] 
      at (6, -9.5) {
    \textbf{Cel:} Wybranie optymalnych hiperparametrów finetuningu \quad
    \textbf{Metryka:} $F_1$-macro
};

% ==================== PRAWA STRONA: Architektura modelu ====================
\begin{scope}[xshift=10cm, yshift=-4cm, scale=1.4, transform shape]
    
    % Tytul (bez tła)
    \node[font=\footnotesize\bfseries, text=gray] at (0.2, 2.5) {BERT\textsubscript{SMALL} (SDPA)};
    
    % Warstwy modelu
    \node[rectangle, draw=freezecolor, fill=freezecolor!30, 
          minimum width=2.8cm, minimum height=0.4cm, font=\tiny] 
          (emb) at (0.2, 2) {Embeddings};
    
    \node[rectangle, draw=freezecolor, fill=freezecolor!25,
          minimum width=2.8cm, minimum height=0.35cm, font=\tiny]
          (l1) at (0.2, 1.5) {Warstwa 1};
    
    \node[rectangle, draw=freezecolor, fill=freezecolor!20,
          minimum width=2.8cm, minimum height=0.35cm, font=\tiny]
          (l2) at (0.2, 1.1) {Warstwa 2};
    
    \node[rectangle, draw=gray!50, fill=gray!10,
          minimum width=2.8cm, minimum height=0.35cm, font=\tiny]
          (l3) at (0.2, 0.7) {Warstwa 3};
          
    \node[rectangle, draw=gray!50, fill=gray!10,
          minimum width=2.8cm, minimum height=0.35cm, font=\tiny]
          (l4) at (0.2, 0.3) {Warstwa 4};
    
    % Klamra dla zamrożonych warstw
    \draw[decorate, decoration={brace, amplitude=5pt, raise=2pt}, freezecolor, line width=1pt]
        (emb.north east) -- (l2.south east) 
        node[midway, right=8pt, font=\tiny, text=freezecolor] {$N_{\text{freeze}}$};
    
    % Śnieżynka
    \node[font=\small, text=freezecolor] at (-1.4, 1.5) {\faIcon{snowflake}};
    
    % Pooling
    \node[rectangle, draw=poolcolor, fill=poolcolor!25,
          minimum width=2.2cm, minimum height=0.4cm, font=\tiny\bfseries,
          rounded corners=2pt]
          (pool) at (0.2, -0.3) {\textcolor{poolcolor}{\faIcon{layer-group}} Pooling};
    
    \draw[->, gray, line width=0.6pt] (l4.south) -- (pool.north);
    
    % Dropdown
    \node[rectangle, draw=dropcolor, fill=dropcolor!25,
          minimum width=2.2cm, minimum height=0.4cm, font=\tiny\bfseries,
          rounded corners=2pt]
          (drop) at (0.2, -0.9) {\textcolor{dropcolor}{\faIcon{tint}} Dropout ($P_{\text{drop}}$)};
    
    \draw[->, gray, line width=0.6pt] (pool.south) -- (drop.north);
    
    % Klasyfikator
    \node[rectangle, draw=evalcolor, fill=evalcolor!20,
          minimum width=2.2cm, minimum height=0.4cm, font=\tiny\bfseries,
          rounded corners=2pt]
          (clf) at (0.2, -1.5) {Klasyfikator};
    
    \draw[->, gray, line width=0.6pt] (drop.south) -- (clf.north);
    
    % Wyjście
    \node[circle, draw=evalcolor, fill=evalcolor!30,
          minimum size=0.5cm, font=\tiny\bfseries]
          (out) at (0.2, -2.2) {$\hat{p}$};
    
    \draw[->, evalcolor, line width=0.8pt] (clf.south) -- (out.north);
    
\end{scope}


\end{tikzpicture}
}

\end{frame}


% \begin{frame}{Proces Klasyfikacji (Modyfikacja)}
%     \centering
%     \resizebox{\textwidth}{!}{%
%     \begin{tikzpicture}[
%         node distance=0.3cm and 0.4cm,
%         process/.style={draw=gray, thick, rounded corners, fill=white, align=center, font=\footnotesize},
%         token/.style={draw=gray!50, fill=tokenGray, rounded corners=3pt, font=\ttfamily\scriptsize, minimum height=0.5cm, inner sep=2pt},
%         special/.style={token, draw=clsBorder, fill=clsGold!30, font=\bfseries\ttfamily\scriptsize},
%         vector/.style={draw=gray!40, fill=gray!10, rectangle, minimum width=0.4cm, minimum height=0.6cm},
%         % STYL AKTYWNYCH WEKTORÓW (CLS i SEP) - SZERSZE Z TEKSTEM
%         activeVector/.style={vector, draw=clsBorder, fill=clsGold, thick, minimum width=0.9cm, font=\tiny\bfseries, text=black},
%         opNode/.style={circle, draw=opPurple, fill=opPurple!10, thick, minimum size=0.9cm, font=\bfseries\tiny, align=center},
%         arrow/.style={->, >=Stealth, thick, color=gray!70},
%         mainArrow/.style={->, >=Stealth, thick, color=clsBorder}
%     ]

%     %% 1. INPUT
%     \node[align=center, font=\scriptsize] (input) {,,Długa recenzja \\ filmowa...''};
%     \node[process, right=0.3cm of input, fill=bertBlue, font=\scriptsize] (tokenizer) {Tokenizer + \\ {[SEP]} Insert};
%     \draw[arrow] (input) -- (tokenizer);

%     %% 2. SEKWENCJA
%     \node[special, right=0.3cm of tokenizer, label={[font=\tiny, color=gray]below:0}] (tokCLS) {[CLS]};
%     \node[token, right=0.05cm of tokCLS, minimum width=0.5cm] (chunk1) {\dots};
%     \node[special, right=0.05cm of chunk1, label={[font=\tiny, color=gray]below:512}] (sep1) {[SEP]};
%     \node[token, right=0.05cm of sep1, minimum width=0.5cm] (chunk2) {\dots};
%     \node[special, right=0.05cm of chunk2, label={[font=\tiny, color=gray]below:1024}] (sep2) {[SEP]};
%     \node[token, right=0.05cm of sep2, minimum width=0.5cm] (chunk3) {\dots};
%     \draw[arrow] (tokenizer) -- (tokCLS);

%     %% 3. BERT ENCODER
%     \node[draw=bertBorder, fill=bertBlue!30, rounded corners, fit={(tokCLS) (chunk3)}, 
%           minimum height=1.8cm, yshift=1.3cm, label={[font=\scriptsize]center:\textbf{BERT Encoder}}] (bert) {};

%     % Zmiana: Strzałki od tokenów specjalnych są złote (mainArrow)
%     \foreach \t in {tokCLS, sep1, sep2} {
%         \draw[mainArrow, shorten >=1pt] (\t.north) -- (\t.north |- bert.south);
%     }
%     \foreach \t in {chunk1, chunk2, chunk3} {
%         \draw[arrow, shorten >=1pt] (\t.north) -- (\t.north |- bert.south);
%     }

%     %% 4. WEKTORY (ZMIANA: Tekst w środku)
%     % Tutaj wpisujemy tekst bezpośrednio do definicji węzła
%     \node[activeVector, above=0.1cm of bert.north -| tokCLS] (vecCLS) {$h_{[CLS]}$};
%     \node[vector, above=0.1cm of bert.north -| chunk1] (vecChunk1) {};
%     \node[activeVector, above=0.1cm of bert.north -| sep1] (vecSEP1) {$h_{[SEP]}$};
%     \node[vector, above=0.1cm of bert.north -| chunk2] (vecChunk2) {};
%     \node[activeVector, above=0.1cm of bert.north -| sep2] (vecSEP2) {$h_{[SEP]}$};
%     \node[vector, above=0.1cm of bert.north -| chunk3] (vecChunk3) {};

%     % Strzałki
%     \draw[mainArrow] (bert.north -| tokCLS) -- (vecCLS);
%     \draw[arrow, dashed] (bert.north -| chunk1) -- (vecChunk1);
%     \draw[mainArrow] (bert.north -| sep1) -- (vecSEP1);
%     \draw[arrow, dashed] (bert.north -| chunk2) -- (vecChunk2);
%     \draw[mainArrow] (bert.north -| sep2) -- (vecSEP2);
%     \draw[arrow, dashed] (bert.north -| chunk3) -- (vecChunk3);

%     %% 5. MEAN POOLING
%     \node[opNode, above=0.8cm of vecSEP1] (mean) {MEAN\\(CLS, SEPs)};

%     \draw[mainArrow, opPurple, out=90, in=180] (vecCLS.north) to (mean.west);
%     \draw[mainArrow, opPurple] (vecSEP1.north) -- (mean.south);
%     \draw[mainArrow, opPurple, out=90, in=0] (vecSEP2.north) to (mean.east);

%     %% 6. GŁOWA
%     \node[process, right=0.5cm of bert, fill=headRed!10, draw=headRed, text width=2.2cm, font=\scriptsize] (head) {\textbf{Głowa Klasyfikacyjna}\\(MLP + Softmax)};
%     \draw[mainArrow, out=0, in=90] (mean.east) to (head.north);

%     %% 7. WYNIK
%     \node[right=0.3cm of head, align=left, font=\tiny] (results) {
%         \textcolor{goodGreen}{Poz: 92\%}\\
%         \textcolor{red}{Neg: 8\%}
%     };
%     \draw[arrow] (head) -- (results);

%     \end{tikzpicture}
%     }
% \end{frame}


%slajd 3
\begin{frame}{Proces Klasyfikacji (BERT Standard)}
    \centering
    \resizebox{\textwidth}{!}{%
    \begin{tikzpicture}[
        node distance=0.3cm and 0.4cm,
        process/.style={draw=gray, thick, rounded corners, fill=white, align=center, font=\footnotesize},
        token/.style={draw=gray!50, fill=tokenGray, rounded corners=3pt, font=\ttfamily\scriptsize, minimum height=0.5cm, inner sep=2pt},
        special/.style={token, draw=clsBorder, fill=clsGold!30, font=\bfseries\ttfamily\scriptsize},
        % BAZOWY STYL WEKTORA (nieaktywne)
        vector/.style={draw=gray!40, fill=gray!10, rectangle, minimum width=0.4cm, minimum height=0.6cm},
        % ZMODYFIKOWANY STYL DLA WEKTORA CLS (Szerszy + tekst w środku)
        clsVector/.style={vector, draw=clsBorder, fill=clsGold, thick, minimum width=0.9cm, font=\tiny\bfseries, text=black},
        arrow/.style={->, >=Stealth, thick, color=gray!70},
        mainArrow/.style={->, >=Stealth, thick, color=clsBorder}
    ]

    %% 1. INPUT
    \node[align=center, font=\scriptsize] (input) {,,Długa recenzja\\filmowa...''};
    \node[process, right=0.3cm of input, fill=bertBlue, font=\scriptsize] (tokenizer) {Tokenizer};
    \draw[arrow] (input) -- (tokenizer);

    %% 2. TOKENY
    \node[special, right=0.3cm of tokenizer] (tokCLS) {[CLS]};
    \node[token, right=0.05cm of tokCLS] (tok1) {Dłu};
    \node[token, right=0.05cm of tok1] (tok2) {\#\#ga};
    \node[token, right=0.05cm of tok2] (tok3) {recenzja};
    \node[token, right=0.05cm of tok3] (tok4) {...};
    \draw[arrow] (tokenizer) -- (tokCLS);

    %% 3. BERT ENCODER
    \node[draw=bertBorder, fill=bertBlue!30, rounded corners, fit={(tokCLS) (tok4)}, 
          minimum height=1.8cm, yshift=1.3cm, label={[font=\scriptsize]center:\textbf{BERT Encoder}}] (bert) {};

    % Zmiana: Strzałka od CLS jest złota
    \draw[mainArrow, shorten >=1pt] (tokCLS.north) -- (tokCLS.north |- bert.south);
    \foreach \t in {tok1, tok2, tok3, tok4} {
        \draw[arrow, shorten >=1pt] (\t.north) -- (\t.north |- bert.south);
    }

    %% 4. WEKTORY (ZMIANA: Tekst wewnątrz)
    % Wektor CLS ma teraz tekst w środku
    \node[clsVector, above=0.1cm of bert.north -| tokCLS] (vecCLS) {$h_{[CLS]}$};
    
    % Pozostałe wektory puste, ale nieco szersze dla estetyki (zdefiniowane w stylu vector)
    \node[vector, above=0.1cm of bert.north -| tok1] (vec1) {};
    \node[vector, above=0.1cm of bert.north -| tok2] (vec2) {};
    \node[vector, above=0.1cm of bert.north -| tok3] (vec3) {};
    \node[vector, above=0.1cm of bert.north -| tok4] (vec4) {};

    % Strzałki
    \draw[mainArrow] (bert.north -| tokCLS) -- (vecCLS);
    \draw[arrow, dashed] (bert.north -| tok1) -- (vec1);
    \draw[arrow, dashed] (bert.north -| tok2) -- (vec2);
    \draw[arrow, dashed] (bert.north -| tok3) -- (vec3);
    \draw[arrow, dashed] (bert.north -| tok4) -- (vec4);

    %% 5. GŁOWA I WYNIK
    \node[process, right=0.5cm of bert, fill=headRed!10, draw=headRed, text width=2.2cm, font=\scriptsize] (head) {\textbf{Głowa Klasyfikacyjna}\\(MLP + Softmax)};
    
    \draw[mainArrow, out=45, in=135] (vecCLS.north) to (head.north);

    \node[right=0.3cm of head, align=left, font=\tiny] (results) {
        \textcolor{goodGreen}{Poz: 92\%} \\
        \textcolor{red}{Neg: 8\%}
    };
    \draw[arrow] (head) -- (results);



    \end{tikzpicture}
    }
\end{frame}


%slajd 4
\begin{frame}{Proces Klasyfikacji (Mean Pooling - Wszystkie Tokeny)}
    \centering
    \resizebox{\textwidth}{!}{%
    \begin{tikzpicture}[
        node distance=0.3cm and 0.4cm,
        process/.style={draw=gray, thick, rounded corners, fill=white, align=center, font=\footnotesize},
        token/.style={draw=gray!50, fill=tokenGray, rounded corners=3pt, font=\ttfamily\scriptsize, minimum height=0.5cm, inner sep=2pt},
        special/.style={token, draw=clsBorder, fill=clsGold!30, font=\bfseries\ttfamily\scriptsize},
        % Nowy styl dla aktywnych tokenów (żółte tło)
        activeToken/.style={token, draw=clsBorder, fill=clsGold!30, font=\ttfamily\scriptsize},
        vector/.style={draw=gray!40, fill=gray!10, rectangle, minimum width=0.4cm, minimum height=0.6cm},
        % STYL AKTYWNYCH WEKTORÓW (CLS)
        activeVector/.style={vector, draw=clsBorder, fill=clsGold, thick, minimum width=0.9cm, font=\tiny\bfseries, text=black},
        % STYL DLA WEKTORÓW TOKENÓW (też aktywne, z etykietami) - ZWĘŻONE
        tokenVector/.style={vector, draw=clsBorder, fill=clsGold, thick, minimum width=0.5cm, font=\tiny\bfseries, text=black},
        opNode/.style={circle, draw=opPurple, fill=opPurple!10, thick, minimum size=0.9cm, font=\bfseries\tiny, align=center},
        arrow/.style={->, >=Stealth, thick, color=gray!70},
        mainArrow/.style={->, >=Stealth, thick, color=clsBorder}
    ]

    %% 1. INPUT
    \node[align=center, font=\scriptsize] (input) {,,Długa recenzja\\filmowa...''};
    \node[process, right=0.3cm of input, fill=bertBlue, font=\scriptsize] (tokenizer) {Tokenizer};
    \draw[arrow] (input) -- (tokenizer);

    %% 2. TOKENY (Wszystkie żółte/aktywne)
    \node[special, right=0.3cm of tokenizer] (tokCLS) {[CLS]};
    \node[activeToken, right=0.05cm of tokCLS] (tok1) {Dłu};
    \node[activeToken, right=0.05cm of tok1] (tok2) {\#\#ga};
    \node[activeToken, right=0.05cm of tok2] (tok3) {recenzja};
    \node[activeToken, right=0.05cm of tok3] (tok4) {...};
    \draw[arrow] (tokenizer) -- (tokCLS);

    %% 3. BERT ENCODER
    \node[draw=bertBorder, fill=bertBlue!30, rounded corners, fit={(tokCLS) (tok4)}, 
          minimum height=1.8cm, yshift=1.3cm, label={[font=\scriptsize]center:\textbf{BERT Encoder}}] (bert) {};

    % Wszystkie strzałki złote
    \draw[mainArrow, shorten >=1pt] (tokCLS.north) -- (tokCLS.north |- bert.south);
    \foreach \t in {tok1, tok2, tok3, tok4} {
        \draw[mainArrow, shorten >=1pt] (\t.north) -- (\t.north |- bert.south);
    }

    %% 4. WEKTORY (Z etykietami h_)
    % Wektor CLS
    \node[activeVector, above=0.1cm of bert.north -| tokCLS] (vecCLS) {$h_{[CLS]}$};
    
    % Pozostałe wektory (z etykietami)
    \node[tokenVector, above=0.1cm of bert.north -| tok1] (vec1) {$h_1$};
    \node[tokenVector, above=0.1cm of bert.north -| tok2] (vec2) {$h_2$};
    \node[tokenVector, above=0.1cm of bert.north -| tok3] (vec3) {$h_3$};
    \node[tokenVector, above=0.1cm of bert.north -| tok4] (vec4) {$\dots$};

    % Strzałki od BERT do wektorów
    \draw[mainArrow] (bert.north -| tokCLS) -- (vecCLS);
    \draw[mainArrow] (bert.north -| tok1) -- (vec1);
    \draw[mainArrow] (bert.north -| tok2) -- (vec2);
    \draw[mainArrow] (bert.north -| tok3) -- (vec3);
    \draw[mainArrow] (bert.north -| tok4) -- (vec4);

    %% 5. MEAN POOLING
    % Centrujemy MEAN względem wszystkich wektorów
    \node[fit=(vecCLS)(vec4), inner sep=0pt] (vectorsFit) {};
    \node[opNode, above=0.8cm of vectorsFit] (mean) {MEAN\\(All)};

    % Połączenia do MEAN (Symetryczne)
    \draw[mainArrow, opPurple, out=90, in=180] (vecCLS.north) to (mean.west);
    \draw[mainArrow, opPurple, out=90, in=225] (vec1.north) to (mean.225);
    \draw[mainArrow, opPurple, out=90, in=270] (vec2.north) to (mean.south);
    \draw[mainArrow, opPurple, out=90, in=315] (vec3.north) to (mean.315);
    \draw[mainArrow, opPurple, out=90, in=0] (vec4.north) to (mean.east);

    %% 6. GŁOWA
    \node[process, right=0.5cm of bert, fill=headRed!10, draw=headRed, text width=2.2cm, font=\scriptsize] (head) {\textbf{Głowa Klasyfikacyjna}\\(MLP + Softmax)};
    
    % Strzałka od MEAN do Głowy
    \draw[mainArrow, out=0, in=135] (mean.east) to (head.north);

    %% 7. WYNIK
    \node[right=0.3cm of head, align=left, font=\tiny] (results) {
        \textcolor{goodGreen}{Poz: 92\%}\\
        \textcolor{red}{Neg: 8\%}
    };
    \draw[arrow] (head) -- (results);

    \end{tikzpicture}
    }
\end{frame}



%slajd 5
\begin{frame}{Wyniki}
\begin{columns}
    \begin{column}{0.7\textheight}
        \begin{table}[t!]
        \centering
        \caption{Wyniki F1-macro na zbiorze testowym}
        \label{tab:e1-f1-results}
        \smallskip
        \resizebox{\textwidth}{!}{%
        \small
        \begin{tabular}{@{}lccc@{}}
        \toprule
        \textbf{Model} & \textbf{IMDB} & \textbf{Hyperpartisan} & \textbf{Arxiv} \\
        \midrule
        \textit{TF-IDF+LR} & -- & -- & -- \\
        \midrule
        \multicolumn{4}{l}{\textit{CLS pooling}} \\
        $N_\text{freeze}=0$, $P_\text{drop}=0.1$ & 93.22 & -- & -- \\
        $N_\text{freeze}=0$, $P_\text{drop}=0.2$ & 93.22 & -- & -- \\
        $N_\text{freeze}=1$, $P_\text{drop}=0.1$ & 92.95 & -- & -- \\
        $N_\text{freeze}=1$, $P_\text{drop}=0.2$ & 92.67 & -- & -- \\
        $N_\text{freeze}=2$, $P_\text{drop}=0.1$ & 92.97 & -- & -- \\
        $N_\text{freeze}=2$, $P_\text{drop}=0.2$ & 92.93 & -- & -- \\
        \midrule
        \multicolumn{4}{l}{\textit{Mean pooling}} \\
        $N_\text{freeze}=0$, $P_\text{drop}=0.1$ & 92.90 & -- & -- \\
        $N_\text{freeze}=0$, $P_\text{drop}=0.2$ & 92.93 & -- & -- \\
        $N_\text{freeze}=1$, $P_\text{drop}=0.1$ & 92.99 & -- & -- \\
        $N_\text{freeze}=1$, $P_\text{drop}=0.2$ & 92.87 & -- & -- \\
        $N_\text{freeze}=2$, $P_\text{drop}=0.1$ & 92.83 & -- & -- \\
        $N_\text{freeze}=2$, $P_\text{drop}=0.2$ & 92.85 & -- & -- \\
        \bottomrule
        \end{tabular}%
        }
        \end{table}
    \end{column}
    \begin{column}{0.3\textwidth}
        \begin{table}[t!]
        \centering
        \caption{Optymalne hiperparametry wybrane na podstawie F1-macro na zbiorze walidacyjnym}
        \label{tab:e1-results}
        \resizebox{\textwidth}{!}{%
        \begin{tabular}{@{}lccc@{}}
        \toprule
        \textbf{Zbiór danych} & $\boldsymbol{N_{freeze}}$ & $\boldsymbol{P_{drop}}$ & \textbf{Pooling} \\
        \midrule
        IMDB          & 2   & 0.2 & Mean \\
        Hyperpartisan & --  & --  & --   \\
        ArXiv         & --  & --  & --   \\
        \bottomrule
        \end{tabular}%
        }
        \end{table}
    \end{column}
\end{columns}
\end{frame}






\begin{frame}[fragile]
\frametitle{FAVOR+ (Modyfikacja)}
\centering
\resizebox{0.85\textwidth}{!}{
    \begin{tikzpicture}[
    x={(1cm,0cm)}, 
    y={(0cm,1cm)}, 
    z={(0.4cm,0.3cm)}, % Perspektywa 3D
    font=\sffamily\bfseries
]

% --- MAKRO DO RYSOWANIA TENSORÓW (MACIERZY 3D) ---
% #1: nazwa węzła (dla pozycjonowania)
% #2: pozycja (x,y)
% #3: szerokość
% #4: wysokość
% #5: głębokość (batch dim)
% #6: kolor wypełnienia
% #7: etykieta na froncie (wymiary)
% #8: etykieta pod spodem (zmienna)
% #9: liczba linii siatki pionowych
% #10: liczba linii siatki poziomych
\newcommand{\drawTensor}[9]{
    % #1: Name
    % #2: Position
    % #3: Width
    % #4: Height
    % #5: Depth
    % #6: Color
    % #7: Front Label
    % #8: Bottom Label
    % #9: Grid Lines (format: nx/ny)

    % Parse grid lines
    \def\parseGrid##1/##2;{\def\gridX{##1}\def\gridY{##2}}
    \expandafter\parseGrid#9;

    % Pozycjonowanie
    \coordinate (#1) at (#2);
    
    % Ściana boczna (widoczna głębia)
    \draw[fill=white, draw=black] 
        ($(#1)+(#3,0,0)$) -- ($(#1)+(#3,#4,0)$) -- ($(#1)+(#3,#4,#5)$) -- ($(#1)+(#3,0,#5)$) -- cycle;
        
    % Ściana górna
    \draw[fill=white, draw=black] 
        ($(#1)+(0,#4,0)$) -- ($(#1)+(#3,#4,0)$) -- ($(#1)+(#3,#4,#5)$) -- ($(#1)+(0,#4,#5)$) -- cycle;
        
    % Ściana przednia (Główna macierz)
    \draw[fill=#6, draw=black] (#1) rectangle ++(#3,#4);
    
    % Siatka na przedniej ścianie
    \begin{scope}
        \clip (#1) rectangle ++(#3,#4);
        % Linie pionowe
        \pgfmathsetmacro{\stepX}{#3/\gridX}
        \foreach \i in {1,...,\gridX} {
            \draw[mygrid] ($(#1)+(\i*\stepX,0)$) -- ($(#1)+(\i*\stepX,#4)$);
        }
        % Linie poziome
        \pgfmathsetmacro{\stepY}{#4/\gridY}
        \foreach \j in {1,...,\gridY} {
            \draw[mygrid] ($(#1)+(0,\j*\stepY)$) -- ($(#1)+(#3,\j*\stepY)$);
        }
    \end{scope}
    
    % Ponowne obrysowanie ramki, żeby była wyraźna
    \draw[thick] (#1) rectangle ++(#3,#4);
    
    % Etykieta wymiarów na środku
    \node[scale=1.2] at ($(#1) + (0.5*#3, 0.5*#4)$) {#7};
    
    % Etykieta zmiennej pod spodem (np. A, V)
    \node[below=0.2cm, scale=1.5] (label_#1) at ($(#1) + (0.5*#3, 0)$) {#8};

    % Definicja punktu skrajnego (prawy górny tył) dla poprawnego fitowania
    \coordinate (#1_top) at ($(#1)+(#3,#4,#5)$);
}

% === LEWA STRONA (Standard Attention) ===

% Macierz A (L x L)
\drawTensor{A}{0,0}{3}{3}{1.5}{myblue}{$L \times L$}{$\mathbf{A}$}{8/8}

% --- HIGHLIGHTS MATRIX A ---
\pgfmathsetmacro{\stepA}{3/8} % 3 width/height, 8 divisions
\pgfmathsetmacro{\rowY}{1*\stepA} % 2nd row from bottom (index 1)
\pgfmathsetmacro{\colX}{6*\stepA} % 7th column from left (index 6)

% Row q (gray)
\draw[fill=gray!30, fill opacity=0.7] (0, \rowY) rectangle (3, \rowY + \stepA);
\node[left, scale=1.5] at (0, \rowY + 0.5*\stepA) {$\mathbf{q}$};

% Column k (blue)
\draw[fill=blue!30, fill opacity=0.7] (\colX, 0) rectangle (\colX + \stepA, 3);
\node[above, scale=1.5] at (\colX + 0.5*\stepA, 3) {$\mathbf{k^\top}$};

% Intersection (green)
\draw[fill=green!60!black, fill opacity=1] (\colX, \rowY) rectangle (\colX + \stepA, \rowY + \stepA);

% Strzałka Batch Dim
\draw[<->, thick] (-0.3, 3, 0) -- (-0.3, 3, 1.5) node[midway, sloped, above, scale=0.6] {batch dim};

% Znak mnożenia
\node[scale=2, text=gray] at (3.8, 1.5) {$\times$};

% Macierz V (L x d)
\drawTensor{V}{4.6,0}{1.5}{3}{1.5}{myyellow}{$L \times d$}{$\mathbf{V}$}{4/8}

% Pudełko grupujące LEWE
\node[draw=red, dashed, thick, rounded corners, inner sep=20pt, fit=(A) (A_top) (label_V) (label_A) (V) (V_top)] (boxLeft) {};
% Etykieta złożoności lewa
\node[above=0cm of boxLeft, yshift=-0.6cm, anchor=south, scale=0.9] {$O(L^2 d)$};
% Podpis "attention mechanism"
\node[below=0.5cm of boxLeft.south, yshift=1cm, scale=0.6, font=\sffamily] {attention mechanism};


% === ŚRODEK (Znak równości/E) ===

\node[scale=2] at (7.9, 1.5) {$\stackrel{\mathbb{E}}{=}$};


% === PRAWA STRONA (Low-Rank) ===

% Przesunięcie dla prawej strony
\def\xoffset{9.5}
\pgfmathsetmacro{\xTimesOne}{\xoffset + 2.4}
\pgfmathsetmacro{\xK}{\xoffset + 3.1}
\pgfmathsetmacro{\xTimesTwo}{\xoffset + 7.1}
\pgfmathsetmacro{\xVTwo}{\xoffset + 7.7}

% Macierz Q' (L x r) - czerwona
\drawTensor{Q}{\xoffset,0}{1.5}{3}{1.5}{myred}{$L \times m$}{$\mathbf{Q}'$}{4/8}

% Znak mnożenia
\node[scale=2, text=gray] at (\xTimesOne, 1.5) {$\times$};

% Macierz K'^T (r x L) - zielona
\drawTensor{K}{\xK, 0.8}{3}{1.5}{1.5}{mygreen}{$m \times L$}{$(\mathbf{K}')^\top$}{8/4}

% --- HIGHLIGHTS PHI ---
\definecolor{mypink}{RGB}{255, 0, 255}

% Highlight row in Q' (phi(q))
% Q' is at (\xoffset, 0), width 1.5, height 3. 8 rows.
% Row height = 3/8 = 0.375. Let's take 2nd row from bottom (y=0.375 to 0.75)
\pgfmathsetmacro{\rowH}{3/8}
\pgfmathsetmacro{\rowY}{1*\rowH} % Start of 2nd row
\draw[mypink, dashed, thick, rounded corners=2pt, fill=mypink, fill opacity=0.2] 
    (\xoffset - 0.1, \rowY) rectangle (\xoffset + 1.5 + 0.1, \rowY + \rowH);
\node[left, mypink, scale=1, inner sep=1pt] at (\xoffset - 0.1, \rowY + 0.5*\rowH) {$\phi(\mathbf{q})$};

% Highlight column in K' (phi(k)^T)
% K' is at (\xK, 0.8), width 3, height 1.5. 8 columns.
% Col width = 3/8 = 0.375. Let's take 7th column (index 6, x=6*0.375)
\pgfmathsetmacro{\colW}{3/8}
\pgfmathsetmacro{\colX}{\xK + 6*\colW}
\draw[mypink, dashed, thick, rounded corners=2pt, fill=mypink, fill opacity=0.2]
    (\colX, 0.8 - 0.1) rectangle (\colX + \colW, 0.8 + 1.5 + 0.1);
\node[above, mypink, scale=1, inner sep=1pt] at (\colX + 0.5*\colW, 0.8 + 1.5 + 0.1) {$\phi(\mathbf{k})^\top$};


% Znak mnożenia
\node[scale=2, text=gray] at (\xTimesTwo, 1.5) {$\times$};

% Macierz V (L x d) - żółta (prawa)
\drawTensor{V2}{\xVTwo, 0}{1.5}{3}{1.5}{myyellow}{$L \times d$}{$\mathbf{V}$}{4/8}

% Pudełko niebieskie (wewnętrzne prawe)
\node[draw=blue!70, dashed, thick, rounded corners, inner sep=10pt, fit=(K) (K_top) (V2) (V2_top) (label_V2)] (boxBlue) {};
\node[above left, scale=0.9] at (boxBlue.north) {$O(Lrd)$};

% Pudełko czerwone (cała prawa strona)
\node[draw=red, dashed, thick, rounded corners, inner sep=30pt, fit=(Q) (Q_top) (label_Q) (boxBlue)] (boxRight) {};
\node[above left, scale=0.9] at (boxRight.north) {$O(Lrd)$};

\end{tikzpicture}
}

\vfill
\vspace{-0.2cm}
\tiny


\centering
\begin{equation*}
    \phi(x) = \frac{1}{\sqrt{m}}\exp\left(-\frac{1}{2}\|x\|^2\right)
    \begin{bmatrix}
    \exp(\omega_1^\top x), \dots, \exp(\omega_m^\top x)
    \end{bmatrix}^\top
\end{equation*}

\begin{equation*}
    \phi^\star(x) = \frac{1}{\sqrt{2m}}\exp\left(-\frac{1}{2}\|x\|^2\right)
    \begin{bmatrix}
    \exp(\omega_1^\top x), \dots, \exp(\omega_m^\top x),
    \exp(-\omega_1^\top x), \dots, \exp(-\omega_m^\top x)
    \end{bmatrix}^\top
\end{equation*}

\begin{gather*}
\mathbb{E}\left[\phi(q)^\top \phi(k)\right] = \mathbb{E}\left[\phi^\star(q)^\top \phi^\star(k)\right] = \exp(q^\top k) \\
\mathrm{Var}\!\left(\phi^\star(q)^\top \phi^\star(k)\right) \leq \mathrm{Var}\!\left(\phi(q)^\top \phi(k)\right)
\end{gather*}

\end{frame}


\begin{frame}[fragile]
\frametitle{LSH Attention}
\centering
\centering
\begin{lrbox}{\tempSlideBox}%
\begin{tikzpicture}[
    font=\sffamily,
    % Styl tokenu jako pudełka
    tokenBox/.style={
        draw=gray!40, 
        fill=white, 
        rounded corners=2pt, 
        minimum width=0.6cm, 
        minimum height=0.5cm, 
        font=\scriptsize\bfseries,
        inner sep=1pt,
        anchor=center
    },
    % Styl badge'a (kropka koloru)
    colorBadge/.style={
        circle,
        minimum size=4pt,
        inner sep=0pt,
        yshift=2pt
    },
    % Styl linii łączących
    flowLine/.style={
        ->, 
        >=Stealth, 
        rounded corners=10pt,
        opacity=0.3,
        line width=0.5pt
    },
    % Styl wyróżnionej linii
    highlightFlow/.style={
        ->, 
        >=Stealth, 
        line width=1.5pt,
        opacity=1.0
    }
]

% Definicje kolorów bucket'ów (zgodne z resztą prezentacji)
\definecolor{bucketGreen}{RGB}{46, 204, 113}
\definecolor{bucketRed}{RGB}{231, 76, 60}
\definecolor{bucketBlue}{RGB}{52, 152, 219}
\definecolor{bucketOrange}{RGB}{241, 196, 15}
\definecolor{maskedGray}{RGB}{190, 190, 190}

% Pozycje Y dla rzędów
\def\yOrig{6.0}   % Rząd oryginalny
\def\ySorted{3.5} % Rząd posortowany

% ==================== GÓRNA CZĘŚĆ: PROCES SORTOWANIA ====================

% Etykieta etapu 1
\node[anchor=west, font=\bfseries\small, text=gray] at (-7.5, \yOrig) {1. HASHOWANIE};
\node[anchor=west, font=\scriptsize, text=gray!80] at (-7.5, \yOrig-0.4) {Przypisanie koszyka (kolor)};

% Rząd 1: Oryginalna sekwencja z kolorowymi kropkami (badgami)
% Definicja danych: ID / Label / Kolor
\foreach \i/\lbl/\col in {%
    0/q_0/bucketRed,%
    1/q_1/bucketOrange,%
    2/q_2/bucketRed,%
    3/q_3/bucketBlue,%
    4/q_4/bucketGreen,%
    5/q_5/bucketOrange,%
    6/q_6/bucketBlue,%
    7/q_7/bucketBlue,%
    8/q_8/bucketBlue,%
    9/q_9/bucketBlue,%
    10/q_{10}/bucketGreen,%
    11/q_{11}/bucketOrange%
} {
    % Rysujemy pudełko
    \node[tokenBox] (orig\i) at (\i*0.8 - 3.0, \yOrig) {$\lbl$};
    % Dodajemy kolorowy badge na górze
    \node[colorBadge, fill=\col, above=-2pt of orig\i.north] {};
}

% Etykieta etapu 2
\node[anchor=west, font=\bfseries\small, text=gray] at (-7.5, \ySorted) {2. SORTOWANIE};
\node[anchor=west, font=\scriptsize, text=gray!80] at (-7.5, \ySorted-0.4) {Grupowanie wg koszyków};

% Rząd 2: Posortowana sekwencja
% Kolejność po sortowaniu (Green -> Red -> Blue -> Orange)
% ID oryginalne / Nowy Index / Label / Kolor / Styl (highlight lub flow)
\foreach \origID/\newID/\lbl/\col/\styl in {%
    4/0/q_4/bucketGreen/highlightFlow,%
    10/1/q_{10}/bucketGreen/highlightFlow,%
    0/2/q_0/bucketRed/flowLine,%
    2/3/q_2/bucketRed/flowLine,%
    7/4/q_7/bucketRed/flowLine,%
    3/5/q_3/bucketBlue/flowLine,%
    6/6/q_6/bucketBlue/flowLine,%
    8/7/q_8/bucketBlue/flowLine,%
    9/8/q_9/bucketBlue/flowLine,%
    1/9/q_1/bucketOrange/flowLine,%
    5/10/q_5/bucketOrange/flowLine,%
    11/11/q_{11}/bucketOrange/flowLine%
} {
    \node[tokenBox, draw=\col!80, fill=\col!10] (sort\newID) at (\newID*0.8 - 3.0, \ySorted) {$\lbl$};
    
    % Rysowanie linii łączących (Flow)
    \draw[\styl, color=\col] (orig\origID.south) to[out=-90, in=90] (sort\newID.north);
}

% ==================== KLAMRY CHUNKÓW ====================
% Pokazujemy, że dzielimy posortowany ciąg na chunki dla uwagi blokowej
% ==================== KLAMRY CHUNKÓW ====================
% 1. Pierwsze 6 (Top)
\draw[decorate, decoration={brace, amplitude=7pt, raise=3pt}, thick, color=gray]
    (sort0.north west) -- (sort5.north east) 
    node[midway, above=8pt, font=\tiny\bfseries, color=gray] {Blok 1};

% 2. Pierwsze 9 (Bottom)
\draw[decorate, decoration={brace, mirror, amplitude=5pt, raise=2pt}, thick, color=gray]
    (sort0.south west) -- (sort8.south east) 
    node[midway, below=8pt, font=\tiny\bfseries, color=gray] {Blok 2};

% 3. Ostatnie 9 (Top)
\draw[decorate, decoration={brace, amplitude=5pt, raise=2pt}, thick, color=gray]
    (sort3.north west) -- (sort11.north east) 
    node[midway, above=8pt, font=\tiny\bfseries, color=gray] {Blok 3};

% 4. Ostatnie 6 (Bottom)
\draw[decorate, decoration={brace, mirror, amplitude=7pt, raise=3pt}, thick, color=gray]
    (sort6.south west) -- (sort11.south east) 
    node[midway, below=8pt, font=\tiny\bfseries, color=gray] {Blok 4};


% ==================== DOLNA CZĘŚĆ: MACIERZ (Bez zmian logicznych, tylko dopasowanie pozycji) ====================
\def\cellsize{0.35}
\def\matrixX{-2.1}
\def\matrixY{-2.8} % Przesunięte w dół, aby zrobić miejsce na dolne klamry

% Makro do rysowania komórki diagonalnej
\newcommand{\diagcell}[4]{
    \pgfmathsetmacro{\cx}{\matrixX + #1*\cellsize}
    \pgfmathsetmacro{\cy}{\matrixY + #2*\cellsize}
    \fill[#3, opacity=0.0] (\cx, \cy) -- (\cx + \cellsize, \cy) -- (\cx, \cy + \cellsize) -- cycle;
    \fill[#4, opacity=0.0] (\cx + \cellsize, \cy) -- (\cx + \cellsize, \cy + \cellsize) -- (\cx, \cy + \cellsize) -- cycle;
}

% Tytuł sekcji dolnej
\node[anchor=west, font=\bfseries\small, text=gray] at (-7.5, 1.8) {3. UWAGA BLOKOWA};

% Tło szare
\fill[maskedGray] (\matrixX, \matrixY) rectangle (\matrixX + 12*\cellsize, \matrixY + 12*\cellsize);

% Etykiety wierszy
\foreach \i/\name/\col in {11/q_4/bucketGreen, 10/q_{10}/bucketGreen, 9/q_0/bucketRed, 8/q_2/bucketRed, 7/q_7/bucketRed, 6/q_3/bucketBlue, 5/q_6/bucketBlue, 4/q_8/bucketBlue, 3/q_9/bucketBlue, 2/q_1/bucketOrange, 1/q_5/bucketOrange, 0/q_{11}/bucketOrange} {
    \node[font=\tiny, text=\col, anchor=east] at (\matrixX - 0.1, \matrixY + \i*\cellsize + 0.5*\cellsize) {$\name$};
}
% Etykiety kolumn
\foreach \i/\name/\col in {0/q_4/bucketGreen, 1/q_{10}/bucketGreen, 2/q_0/bucketRed, 3/q_2/bucketRed, 4/q_7/bucketRed, 5/q_3/bucketBlue, 6/q_6/bucketBlue, 7/q_8/bucketBlue, 8/q_9/bucketBlue, 9/q_1/bucketOrange, 10/q_5/bucketOrange, 11/q_{11}/bucketOrange} {
    \node[font=\tiny, text=\col, anchor=south] at (\matrixX + \i*\cellsize + 0.5*\cellsize, \matrixY + 12*\cellsize + 0.1) {$\name$};
}

% --- RYSOWANIE BLOKÓW (Skrócona wersja logiczna z poprzedniego kodu) ---

% Blok 1 (Wiersze 9-11 [idx], Kolumny 0-5) -> odpowiada q4, q10, q0 (góra macierzy w renderze)
% Wiersze w pętli foreach idą od dołu (0) do góry (11).
% q4 to index 11 (top). q10 to 10. q0 to 9.

% Zielony (q4, q10 vs q4, q10) -> (W: 10,11; K: 0,1)
\foreach \row in {10, 11} \foreach \col in {0, 1} \fill[bucketGreen] (\matrixX + \col*\cellsize, \matrixY + \row*\cellsize) rectangle +(\cellsize, \cellsize);

% Zielony-Czerwony (W: 10,11; K: 2-4)
\foreach \row in {10, 11} \foreach \col in {2, 3, 4} \diagcell{\col}{\row}{bucketGreen}{bucketRed};

% Zielony-Niebieski (W: 10,11; K: 5)
\foreach \row in {10, 11} \diagcell{5}{\row}{bucketGreen}{bucketBlue};

% Czerwony-Zielony (W: 9; K: 0-1)
\foreach \col in {0, 1} \diagcell{\col}{9}{bucketRed}{bucketGreen};

% Czerwony (W: 9; K: 2-4)
\foreach \col in {2, 3, 4} \fill[bucketRed] (\matrixX + \col*\cellsize, \matrixY + 9*\cellsize) rectangle +(\cellsize, \cellsize);

% Czerwony-Niebieski (W: 9; K: 5)
\diagcell{5}{9}{bucketRed}{bucketBlue};


% Blok 2 (Wiersze 6-8 -> q2, q7, q3; Kolumny 0-8)
% q2(8), q7(7), q3(6)

% Czerwony-Zielony (W: 7,8; K: 0-1)
\foreach \row in {7, 8} \foreach \col in {0, 1} \diagcell{\col}{\row}{bucketRed}{bucketGreen};

% Czerwony (W: 7,8; K: 2-4)
\foreach \row in {7, 8} \foreach \col in {2, 3, 4} \fill[bucketRed] (\matrixX + \col*\cellsize, \matrixY + \row*\cellsize) rectangle +(\cellsize, \cellsize);

% Czerwony-Niebieski (W: 7,8; K: 5-8)
\foreach \row in {7, 8} \foreach \col in {5, ..., 8} \diagcell{\col}{\row}{bucketRed}{bucketBlue};

% Niebieski-Zielony (W: 6; K: 0-1)
\foreach \col in {0, 1} \diagcell{\col}{6}{bucketBlue}{bucketGreen};
% Niebieski-Czerwony (W: 6; K: 2-4)
\foreach \col in {2, 3, 4} \diagcell{\col}{6}{bucketBlue}{bucketRed};
% Niebieski (W: 6; K: 5-8)
\foreach \col in {5, ..., 8} \fill[bucketBlue] (\matrixX + \col*\cellsize, \matrixY + 6*\cellsize) rectangle +(\cellsize, \cellsize);


% Blok 3 (Wiersze 3-5 -> q6, q8, q9; Kolumny 3-11)
% q6(5), q8(4), q9(3)

% Niebieski-Czerwony (W: 4,5; K: 3,4)
\foreach \row in {4, 5} \foreach \col in {3, 4} \diagcell{\col}{\row}{bucketBlue}{bucketRed};
% Niebieski (W: 4,5; K: 5-8)
\foreach \row in {4, 5} \foreach \col in {5, ..., 8} \fill[bucketBlue] (\matrixX + \col*\cellsize, \matrixY + \row*\cellsize) rectangle +(\cellsize, \cellsize);
% Niebieski-Pom (W: 4,5; K: 9-11)
\foreach \row in {4, 5} \foreach \col in {9, ..., 11} \diagcell{\col}{\row}{bucketBlue}{bucketOrange};

% Niebieski-Czerwony (W: 3; K: 3,4)
\foreach \col in {3, 4} \diagcell{\col}{3}{bucketBlue}{bucketRed};
% Niebieski (W: 3; K: 5-8)
\foreach \col in {5, ..., 8} \fill[bucketBlue] (\matrixX + \col*\cellsize, \matrixY + 3*\cellsize) rectangle +(\cellsize, \cellsize);
% Niebieski-Pom (W: 3; K: 9-11)
\foreach \col in {9, ..., 11} \diagcell{\col}{3}{bucketBlue}{bucketOrange};


% Blok 4 (Wiersze 0-2 -> q11, q1, q5; Kolumny 6-11)
% q11(2), q1(1), q5(0)

% Pom-Niebieski (W: 0-2; K: 6-8)
\foreach \row in {0, 1, 2} \foreach \col in {6, 7, 8} \diagcell{\col}{\row}{bucketOrange}{bucketBlue};
% Pom (W: 0-2; K: 9-11)
\foreach \row in {0, 1, 2} \foreach \col in {9, ..., 11} \fill[bucketOrange] (\matrixX + \col*\cellsize, \matrixY + \row*\cellsize) rectangle +(\cellsize, \cellsize);


% Linie siatki
\foreach \i in {0, ..., 12} {
    \draw[gray!50, thin] (\matrixX + \i*\cellsize, \matrixY) -- (\matrixX + \i*\cellsize, \matrixY + 12*\cellsize);
    \draw[gray!50, thin] (\matrixX, \matrixY + \i*\cellsize) -- (\matrixX + 12*\cellsize, \matrixY + \i*\cellsize);
}

% Obramowania bloków (Grube)
% Blok 1: Top-Left (6x3)
\draw[line width=1.5pt] (\matrixX, \matrixY + 9*\cellsize) rectangle (\matrixX + 6*\cellsize, \matrixY + 12*\cellsize);
% Blok 2: Mid (9x3)
\draw[line width=1.5pt] (\matrixX, \matrixY + 6*\cellsize) rectangle (\matrixX + 9*\cellsize, \matrixY + 9*\cellsize);
% Blok 3: Mid (9x3)
\draw[line width=1.5pt] (\matrixX + 3*\cellsize, \matrixY + 3*\cellsize) rectangle (\matrixX + 12*\cellsize, \matrixY + 6*\cellsize);
% Blok 4: Bot-Right (6x3)
\draw[line width=1.5pt] (\matrixX + 6*\cellsize, \matrixY) rectangle (\matrixX + 12*\cellsize, \matrixY + 3*\cellsize);

% Ramka całości
\draw[thick] (\matrixX, \matrixY) rectangle (\matrixX + 12*\cellsize, \matrixY + 12*\cellsize);

% ==================== LEGENDA (Po lewej stronie) ====================

\fill[maskedGray] (2.6, 0.6) rectangle +(0.3, 0.3);
\node[font=\tiny, anchor=west] at (3.0, 0.75) {Zamaskowane};

\draw[line width=1.5pt] (2.6, 0.1) rectangle +(0.3, 0.3);
\node[font=\tiny, anchor=west] at (3.0, 0.25) {Granica bloku};

\fill[bucketGreen] (2.6, -0.4) rectangle +(0.3, 0.3);
\node[font=\tiny, anchor=west] at (3.0, -0.25) {Ten sam koszyk};

% ==================== KLAMRA PODSUMOWUJĄCA (Po prawej) ====================
\draw[decorate, decoration={brace, amplitude=10pt, mirror}, thick, color=black]
    (6.5, -2.8) -- (6.5, 6.5) 
    node[midway, right=15pt, align=center, font=\normalsize] {$\displaystyle\times\, n_{\text{rounds}}$\\\\[6pt]$\displaystyle\frac{1}{n_{\text{rounds}}}\sum_{r=1}^{n_{\text{rounds}}}$};

\end{tikzpicture}
\end{lrbox}
\resizebox{!}{0.9\textheight}{\usebox{\tempSlideBox}}
\end{frame}


\begin{frame}[fragile]
\frametitle{LSH Attention (Modyfikacja)}
\centering
\centering
\begin{lrbox}{\tempSlideBox}%
\begin{tikzpicture}[
    font=\sffamily,
    % Styl tokenu jako pudełka
    tokenBox/.style={
        draw=gray!40, 
        fill=white, 
        rounded corners=2pt, 
        minimum width=0.6cm, 
        minimum height=0.5cm, 
        font=\scriptsize\bfseries,
        inner sep=1pt,
        anchor=center
    },
    % Styl badge'a (kropka koloru)
    colorBadge/.style={
        circle,
        minimum size=4pt,
        inner sep=0pt,
        yshift=2pt
    },
    % Styl linii łączących
    flowLine/.style={
        ->, 
        >=Stealth, 
        rounded corners=10pt,
        opacity=0.3,
        line width=0.5pt
    },
    % Styl wyróżnionej linii
    highlightFlow/.style={
        ->, 
        >=Stealth, 
        line width=1.5pt,
        opacity=1.0
    }
]

% Definicje kolorów bucket'ów (zgodne z resztą prezentacji)
\definecolor{bucketGreen}{RGB}{46, 204, 113}
\definecolor{bucketRed}{RGB}{231, 76, 60}
\definecolor{bucketBlue}{RGB}{52, 152, 219}
\definecolor{bucketOrange}{RGB}{241, 196, 15}
\definecolor{maskedGray}{RGB}{190, 190, 190}

% Pozycje Y dla rzędów
\def\yOrig{6.0}   % Rząd oryginalny
\def\ySorted{3.5} % Rząd posortowany

% ==================== GÓRNA CZĘŚĆ: PROCES SORTOWANIA ====================

% Etykieta etapu 1
\node[anchor=west, font=\bfseries\small, text=gray] at (-7.5, \yOrig) {1. HASHOWANIE};
\node[anchor=west, font=\scriptsize, text=gray!80] at (-7.5, \yOrig-0.4) {Przypisanie koszyka (kolor)};

% Rząd 1: Oryginalna sekwencja z kolorowymi kropkami (badgami)
% Definicja danych: ID / Label / Kolor
\foreach \i/\lbl/\col in {%
    0/q_0/bucketRed,%
    1/q_1/bucketOrange,%
    2/q_2/bucketRed,%
    3/q_3/bucketBlue,%
    4/q_4/bucketGreen,%
    5/q_5/bucketOrange,%
    6/q_6/bucketBlue,%
    7/q_7/bucketBlue,%
    8/q_8/bucketBlue,%
    9/q_9/bucketBlue,%
    10/q_{10}/bucketGreen,%
    11/q_{11}/bucketOrange%
} {
    % Rysujemy pudełko
    \node[tokenBox] (orig\i) at (\i*0.8 - 3.0, \yOrig) {$\lbl$};
    % Dodajemy kolorowy badge na górze
    \node[colorBadge, fill=\col, above=-2pt of orig\i.north] {};
}

% Etykieta etapu 2
\node[anchor=west, font=\bfseries\small, text=gray] at (-7.5, \ySorted) {2. SORTOWANIE};
\node[anchor=west, font=\scriptsize, text=gray!80] at (-7.5, \ySorted-0.4) {Grupowanie wg koszyków};

% Rząd 2: Posortowana sekwencja
% Kolejność po sortowaniu (Green -> Red -> Blue -> Orange)
% ID oryginalne / Nowy Index / Label / Kolor / Styl (highlight lub flow)
\foreach \origID/\newID/\lbl/\col/\styl in {%
    4/0/q_4/bucketGreen/highlightFlow,%
    10/1/q_{10}/bucketGreen/highlightFlow,%
    0/2/q_0/bucketRed/flowLine,%
    2/3/q_2/bucketRed/flowLine,%
    7/4/q_7/bucketRed/flowLine,%
    3/5/q_3/bucketBlue/flowLine,%
    6/6/q_6/bucketBlue/flowLine,%
    8/7/q_8/bucketBlue/flowLine,%
    9/8/q_9/bucketBlue/flowLine,%
    1/9/q_1/bucketOrange/flowLine,%
    5/10/q_5/bucketOrange/flowLine,%
    11/11/q_{11}/bucketOrange/flowLine%
} {
    \node[tokenBox, draw=\col!80, fill=\col!10] (sort\newID) at (\newID*0.8 - 3.0, \ySorted) {$\lbl$};
    
    % Rysowanie linii łączących (Flow)
    \draw[\styl, color=\col] (orig\origID.south) to[out=-90, in=90] (sort\newID.north);
}

% ==================== KLAMRY CHUNKÓW ====================
% Pokazujemy, że dzielimy posortowany ciąg na chunki dla uwagi blokowej
% ==================== KLAMRY CHUNKÓW ====================
% 1. Pierwsze 6 (Top)
\draw[decorate, decoration={brace, amplitude=7pt, raise=3pt}, thick, color=gray]
    (sort0.north west) -- (sort5.north east) 
    node[midway, above=8pt, font=\tiny\bfseries, color=gray] {Blok 1};

% 2. Pierwsze 9 (Bottom)
\draw[decorate, decoration={brace, mirror, amplitude=5pt, raise=2pt}, thick, color=gray]
    (sort0.south west) -- (sort8.south east) 
    node[midway, below=8pt, font=\tiny\bfseries, color=gray] {Blok 2};

% 3. Ostatnie 9 (Top)
\draw[decorate, decoration={brace, amplitude=5pt, raise=2pt}, thick, color=gray]
    (sort3.north west) -- (sort11.north east) 
    node[midway, above=8pt, font=\tiny\bfseries, color=gray] {Blok 3};

% 4. Ostatnie 6 (Bottom)
\draw[decorate, decoration={brace, mirror, amplitude=7pt, raise=3pt}, thick, color=gray]
    (sort6.south west) -- (sort11.south east) 
    node[midway, below=8pt, font=\tiny\bfseries, color=gray] {Blok 4};


% ==================== DOLNA CZĘŚĆ: MACIERZ (Bez zmian logicznych, tylko dopasowanie pozycji) ====================
\def\cellsize{0.35}
\def\matrixX{-2.1}
\def\matrixY{-2.8} % Przesunięte w dół, aby zrobić miejsce na dolne klamry

% Makro do rysowania komórki diagonalnej
\newcommand{\diagcell}[4]{
    \pgfmathsetmacro{\cx}{\matrixX + #1*\cellsize}
    \pgfmathsetmacro{\cy}{\matrixY + #2*\cellsize}
    \fill[#3, opacity=0.5] (\cx, \cy) -- (\cx + \cellsize, \cy) -- (\cx, \cy + \cellsize) -- cycle;
    \fill[#4, opacity=0.5] (\cx + \cellsize, \cy) -- (\cx + \cellsize, \cy + \cellsize) -- (\cx, \cy + \cellsize) -- cycle;
}

% Tytuł sekcji dolnej
\node[anchor=west, font=\bfseries\small, text=gray] at (-7.5, 1.8) {3. UWAGA BLOKOWA};

% Tło szare
\fill[maskedGray] (\matrixX, \matrixY) rectangle (\matrixX + 12*\cellsize, \matrixY + 12*\cellsize);

% Etykiety wierszy
\foreach \i/\name/\col in {11/q_4/bucketGreen, 10/q_{10}/bucketGreen, 9/q_0/bucketRed, 8/q_2/bucketRed, 7/q_7/bucketRed, 6/q_3/bucketBlue, 5/q_6/bucketBlue, 4/q_8/bucketBlue, 3/q_9/bucketBlue, 2/q_1/bucketOrange, 1/q_5/bucketOrange, 0/q_{11}/bucketOrange} {
    \node[font=\tiny, text=\col, anchor=east] at (\matrixX - 0.1, \matrixY + \i*\cellsize + 0.5*\cellsize) {$\name$};
}
% Etykiety kolumn
\foreach \i/\name/\col in {0/q_4/bucketGreen, 1/q_{10}/bucketGreen, 2/q_0/bucketRed, 3/q_2/bucketRed, 4/q_7/bucketRed, 5/q_3/bucketBlue, 6/q_6/bucketBlue, 7/q_8/bucketBlue, 8/q_9/bucketBlue, 9/q_1/bucketOrange, 10/q_5/bucketOrange, 11/q_{11}/bucketOrange} {
    \node[font=\tiny, text=\col, anchor=south] at (\matrixX + \i*\cellsize + 0.5*\cellsize, \matrixY + 12*\cellsize + 0.1) {$\name$};
}

% --- RYSOWANIE BLOKÓW (Skrócona wersja logiczna z poprzedniego kodu) ---

% Blok 1 (Wiersze 9-11 [idx], Kolumny 0-5) -> odpowiada q4, q10, q0 (góra macierzy w renderze)
% Wiersze w pętli foreach idą od dołu (0) do góry (11).
% q4 to index 11 (top). q10 to 10. q0 to 9.

% Zielony (q4, q10 vs q4, q10) -> (W: 10,11; K: 0,1)
\foreach \row in {10, 11} \foreach \col in {0, 1} \fill[bucketGreen] (\matrixX + \col*\cellsize, \matrixY + \row*\cellsize) rectangle +(\cellsize, \cellsize);

% Zielony-Czerwony (W: 10,11; K: 2-4)
\foreach \row in {10, 11} \foreach \col in {2, 3, 4} \diagcell{\col}{\row}{bucketGreen}{bucketRed};

% Zielony-Niebieski (W: 10,11; K: 5)
\foreach \row in {10, 11} \diagcell{5}{\row}{bucketGreen}{bucketBlue};

% Czerwony-Zielony (W: 9; K: 0-1)
\foreach \col in {0, 1} \diagcell{\col}{9}{bucketRed}{bucketGreen};

% Czerwony (W: 9; K: 2-4)
\foreach \col in {2, 3, 4} \fill[bucketRed] (\matrixX + \col*\cellsize, \matrixY + 9*\cellsize) rectangle +(\cellsize, \cellsize);

% Czerwony-Niebieski (W: 9; K: 5)
\diagcell{5}{9}{bucketRed}{bucketBlue};


% Blok 2 (Wiersze 6-8 -> q2, q7, q3; Kolumny 0-8)
% q2(8), q7(7), q3(6)

% Czerwony-Zielony (W: 7,8; K: 0-1)
\foreach \row in {7, 8} \foreach \col in {0, 1} \diagcell{\col}{\row}{bucketRed}{bucketGreen};

% Czerwony (W: 7,8; K: 2-4)
\foreach \row in {7, 8} \foreach \col in {2, 3, 4} \fill[bucketRed] (\matrixX + \col*\cellsize, \matrixY + \row*\cellsize) rectangle +(\cellsize, \cellsize);

% Czerwony-Niebieski (W: 7,8; K: 5-8)
\foreach \row in {7, 8} \foreach \col in {5, ..., 8} \diagcell{\col}{\row}{bucketRed}{bucketBlue};

% Niebieski-Zielony (W: 6; K: 0-1)
\foreach \col in {0, 1} \diagcell{\col}{6}{bucketBlue}{bucketGreen};
% Niebieski-Czerwony (W: 6; K: 2-4)
\foreach \col in {2, 3, 4} \diagcell{\col}{6}{bucketBlue}{bucketRed};
% Niebieski (W: 6; K: 5-8)
\foreach \col in {5, ..., 8} \fill[bucketBlue] (\matrixX + \col*\cellsize, \matrixY + 6*\cellsize) rectangle +(\cellsize, \cellsize);


% Blok 3 (Wiersze 3-5 -> q6, q8, q9; Kolumny 3-11)
% q6(5), q8(4), q9(3)

% Niebieski-Czerwony (W: 4,5; K: 3,4)
\foreach \row in {4, 5} \foreach \col in {3, 4} \diagcell{\col}{\row}{bucketBlue}{bucketRed};
% Niebieski (W: 4,5; K: 5-8)
\foreach \row in {4, 5} \foreach \col in {5, ..., 8} \fill[bucketBlue] (\matrixX + \col*\cellsize, \matrixY + \row*\cellsize) rectangle +(\cellsize, \cellsize);
% Niebieski-Pom (W: 4,5; K: 9-11)
\foreach \row in {4, 5} \foreach \col in {9, ..., 11} \diagcell{\col}{\row}{bucketBlue}{bucketOrange};

% Niebieski-Czerwony (W: 3; K: 3,4)
\foreach \col in {3, 4} \diagcell{\col}{3}{bucketBlue}{bucketRed};
% Niebieski (W: 3; K: 5-8)
\foreach \col in {5, ..., 8} \fill[bucketBlue] (\matrixX + \col*\cellsize, \matrixY + 3*\cellsize) rectangle +(\cellsize, \cellsize);
% Niebieski-Pom (W: 3; K: 9-11)
\foreach \col in {9, ..., 11} \diagcell{\col}{3}{bucketBlue}{bucketOrange};


% Blok 4 (Wiersze 0-2 -> q11, q1, q5; Kolumny 6-11)
% q11(2), q1(1), q5(0)

% Pom-Niebieski (W: 0-2; K: 6-8)
\foreach \row in {0, 1, 2} \foreach \col in {6, 7, 8} \diagcell{\col}{\row}{bucketOrange}{bucketBlue};
% Pom (W: 0-2; K: 9-11)
\foreach \row in {0, 1, 2} \foreach \col in {9, ..., 11} \fill[bucketOrange] (\matrixX + \col*\cellsize, \matrixY + \row*\cellsize) rectangle +(\cellsize, \cellsize);


% Linie siatki
\foreach \i in {0, ..., 12} {
    \draw[gray!50, thin] (\matrixX + \i*\cellsize, \matrixY) -- (\matrixX + \i*\cellsize, \matrixY + 12*\cellsize);
    \draw[gray!50, thin] (\matrixX, \matrixY + \i*\cellsize) -- (\matrixX + 12*\cellsize, \matrixY + \i*\cellsize);
}

% Obramowania bloków (Grube)
% Blok 1: Top-Left (6x3)
\draw[line width=1.5pt] (\matrixX, \matrixY + 9*\cellsize) rectangle (\matrixX + 6*\cellsize, \matrixY + 12*\cellsize);
% Blok 2: Mid (9x3)
\draw[line width=1.5pt] (\matrixX, \matrixY + 6*\cellsize) rectangle (\matrixX + 9*\cellsize, \matrixY + 9*\cellsize);
% Blok 3: Mid (9x3)
\draw[line width=1.5pt] (\matrixX + 3*\cellsize, \matrixY + 3*\cellsize) rectangle (\matrixX + 12*\cellsize, \matrixY + 6*\cellsize);
% Blok 4: Bot-Right (6x3)
\draw[line width=1.5pt] (\matrixX + 6*\cellsize, \matrixY) rectangle (\matrixX + 12*\cellsize, \matrixY + 3*\cellsize);

% Ramka całości
\draw[thick] (\matrixX, \matrixY) rectangle (\matrixX + 12*\cellsize, \matrixY + 12*\cellsize);

% ==================== LEGENDA (Po lewej stronie) ====================

\fill[maskedGray] (2.6, 0.6) rectangle +(0.3, 0.3);
\node[font=\tiny, anchor=west] at (3.0, 0.75) {Zamaskowane};

\draw[line width=1.5pt] (2.6, 0.1) rectangle +(0.3, 0.3);
\node[font=\tiny, anchor=west] at (3.0, 0.25) {Granica bloku};

\fill[bucketGreen] (2.6, -0.4) rectangle +(0.3, 0.3);
\node[font=\tiny, anchor=west] at (3.0, -0.25) {Ten sam koszyk};

\fill[bucketRed, opacity=1.0] (2.6, -0.9) -- (2.9, -0.9) -- (2.6, -0.6) -- cycle;
\fill[bucketGreen, opacity=1.0] (2.9, -0.9) -- (2.9, -0.6) -- (2.6, -0.6) -- cycle;
\draw[gray!60, thin] (2.6, -0.9) rectangle (2.9, -0.6);
\node[font=\tiny, anchor=west, text width=4cm] at (3.0, -0.75) {Różne koszyki, ten sam blok};

% ==================== KLAMRA PODSUMOWUJĄCA (Po prawej) ====================
\draw[decorate, decoration={brace, amplitude=10pt, mirror}, thick, color=black]
    (6.5, -2.8) -- (6.5, 6.5) 
    node[midway, right=15pt, align=center, font=\normalsize] {$\displaystyle\times\, n_{\text{rounds}}$\\\\[6pt]$\displaystyle\frac{1}{n_{\text{rounds}}}\sum_{r=1}^{n_{\text{rounds}}}$};

\end{tikzpicture}
\end{lrbox}
\resizebox{!}{0.9\textheight}{\usebox{\tempSlideBox}}
\end{frame}


\begin{frame}[fragile]{LSH Bez Maski}
\centering
\begin{figure}[ht]
\centering
\begin{tikzpicture}
\begin{axis}[
    width=9cm,
    height=6cm,
    xlabel={Epoka},
    ylabel={Strata Cross Entropy},
    grid=both,
    legend pos=north east,
]
\addplot table [x=epoch, y=mask, col sep=comma] {
epoch,mask,nomask
1,4.44271702743161,4.278868550759545
2,3.256857108516832,3.105319842747142
3,3.002335852120413,2.863407068620733
4,2.8583454442749727,2.723390058629738
5,2.752136091176379,2.6210565643691153
6,2.6664045282683695,2.541103008319291
7,2.594955890370912,2.474110451820012
8,2.5378610438866005,2.4205952064782754
9,2.4910680676122703,2.3766953898709944
10,2.4561578081522715,2.3447094036548393
};
\addlegendentry{Maska}

\addplot table [x=epoch, y=nomask, col sep=comma] {
epoch,mask,nomask
1,4.44271702743161,4.278868550759545
2,3.256857108516832,3.105319842747142
3,3.002335852120413,2.863407068620733
4,2.8583454442749727,2.723390058629738
5,2.752136091176379,2.6210565643691153
6,2.6664045282683695,2.541103008319291
7,2.594955890370912,2.474110451820012
8,2.5378610438866005,2.4205952064782754
9,2.4910680676122703,2.3766953898709944
10,2.4561578081522715,2.3447094036548393
};
\addlegendentry{Brak Maski}

\end{axis}
\end{tikzpicture}
\caption{\scriptsize Porównanie pretreningu LSH -- na zbiorze Wikipedia w konfiguracji \texttt{num\_hashes = 2, chunk\_size = 64} -- w zależności od maskowania wewnątrz koszyków. Wykres przedstawia przebieg straty cross-entropy w kolejnych epokach dla dwóch wariantów: \texttt{mask\_withing\_chunks=true} (\textit{maska}) oraz \texttt{mask\_withing\_chunks=false} (\textit{brak maski}). Czas treningu i zużycie GPU różnią się w stopniu znikomym.}
\label{fig:lsh-masking-learning}
\end{figure}
\end{frame}



\begin{frame}[fragile]
\frametitle{Warianty atencji LSH i FAVOR+}
\resizebox{\textwidth}{!}{
\begin{tikzpicture}[
    node distance=0.4cm,
    >={Stealth[round]},
    variantbox/.style={rectangle, rounded corners=2pt, draw=#1, fill=#1!25,
                       minimum width=1.6cm, minimum height=0.45cm,
                       font=\tiny\bfseries, text=black},
    stagebox/.style={rectangle, rounded corners=5pt, draw=#1, fill=#1!20,
                     minimum width=1.8cm, minimum height=2.8cm,
                     font=\small\bfseries, line width=1.2pt},
    databox/.style={rectangle, rounded corners=2pt, draw=#1, fill=#1!30,
                    minimum width=1.4cm, minimum height=0.6cm,
                    font=\scriptsize\bfseries},
    arrow/.style={->, line width=0.8pt, color=gray!70},
    bigarrow/.style={->, line width=2pt, color=#1}
]

% ==================== LEWA STRONA: Warianty atencji ====================

\begin{scope}[shift={(-6.5,0)}, scale=1.3, transform shape]
    \node[font=\scriptsize\bfseries, text=gray] at (0, 1.5) {BERT\textsubscript{SMALL}};

    % LSH
    \node[font=\tiny\bfseries, text=lshcolor] at (-0.8, 1.1) {LSH};
    \node[variantbox=lshcolor] (lsh1) at (-0.8, 0.7) {2h, 64c};
    \node[variantbox=lshcolor] (lsh2) at (-0.8, 0.2) {2h, 128c};
    \node[variantbox=lshcolor] (lsh3) at (-0.8, -0.3) {4h, 64c};
    \node[variantbox=lshcolor] (lsh4) at (-0.8, -0.8) {4h, 128c};

    % FAVOR
    \node[font=\tiny\bfseries, text=favorcolor] at (1.2, 1.1) {FAVOR+};
    \node[variantbox=favorcolor] (fav1) at (1.2, 0.7) {$N_f$=0.125};
    \node[variantbox=favorcolor] (fav2) at (1.2, 0.2) {$N_f$=0.25};
    \node[variantbox=favorcolor] (fav3) at (1.2, -0.3) {$N_f$=0.5};
    \node[variantbox=favorcolor] (fav4) at (1.2, -0.8) {$N_f$=1.0};
\end{scope}

% Strzałka od wariantów do Pretrain
\draw[bigarrow=gray!60] (-3.8, 0) -- (-2.6, 0);

% ==================== ŚRODEK: Pipeline ====================

% Etap 1: Pretraining
\node[stagebox=pretraincolor, minimum width=1.0cm, minimum height=2cm] (pre) at (-2.0, 0) {};
\node[font=\scriptsize\bfseries, text=pretraincolor, rotate=90] at (-2.0, 0) {PRETRAIN};

\draw[bigarrow=pretraincolor!70] (-1.4, 0) -- (0.4, 0);

% Etap 2: TAPT
\node[stagebox=taptcolor, minimum width=1.0cm, minimum height=2cm] (tapt) at (1.0, 0) {};
\node[font=\scriptsize\bfseries, text=taptcolor, rotate=90] at (1.0, 0) {TAPT};

\draw[bigarrow=taptcolor!70] (1.6, 0) -- (3.4, 0);

% Etap 3: Finetuning
\node[stagebox=finetunecolor, minimum width=1.cm, minimum height=2cm] (fine) at (4.0, 0) {};
\node[font=\scriptsize\bfseries, text=finetunecolor, rotate=90] at (4.0, 0) {FINETUNE};

% ==================== GÓRA: Zbiory danych ====================
\node[databox=gray] (d_wiki) at (-2.0, 2.5) {Wikipedia};
\draw[arrow] (d_wiki.south) -- (pre.north);

\node[databox=imdbcolor] (d_imdb) at (0.5, 2.5) {IMDB};
\node[databox=hypercolor] (d_hyper) at (2.5, 2.5) {Hyperpart.};
\node[databox=arxivcolor] (d_arxiv) at (4.5, 2.5) {ArXiv};

% Klamra dla zbiorów
\draw[decorate, decoration={brace, amplitude=5pt, mirror, raise=2pt}, line width=1pt, gray]
    (d_imdb.south west) -- (d_arxiv.south east);

% Strzałki od klamry do TAPT i FINETUNE
\draw[arrow] (2.5, 1.95) -- (2.5, 1.8) -| (tapt.north);
\draw[arrow] (2.5, 1.95) -- (2.5, 1.8) -| (fine.north);

% Adnotacja pod pipeline
\node[font=\tiny\bfseries, text=evalcolor, align=center] at (1.0, -1.5) {
    Wykonujemy cały pipeline 24 razy\\
    (8 wariantów $\times$ 3 zbiory)
};

% ==================== PRAWA STRONA: Wynik ====================

% Strzałka do wyniku
\draw[bigarrow=gray!60] (4.6, 0) -- (5.8, 0);

% Wynik końcowy
\node[rectangle, rounded corners=5pt, draw=evalcolor, fill=evalcolor!20,
      minimum width=2.5cm, minimum height=1.5cm, align=center, font=\scriptsize\bfseries] 
      (result) at (7.0, 0) {
    24 Wyniki
};

% Podsumowanie na dole
\node[rectangle, rounded corners=5pt, draw=evalcolor, fill=evalcolor!10,
      minimum width=12cm, minimum height=0.6cm, font=\scriptsize] 
      at (0, -3.5) {
    \textbf{Cel:} Porównanie mechanizmów LSH i FAVOR+ z różnymi parametrami \quad
    \textbf{Metryki:} $F_1$-macro, czas, RAM
};

\end{tikzpicture}
}
\end{frame}



\begin{frame}{Wyniki}
\end{frame}


\end{document}